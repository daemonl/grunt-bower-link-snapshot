// Generated by CoffeeScript 1.9.1

/*
 * grunt-bower-link-snapshot
 * https://github.com/daemonl/grunt-bower-link-snapshot
 *
 * Copyright (c) 2015 Damien Whitten
 * Licensed under the MIT license.
 */

(function() {
  var Bower, CLITool, Git, bower, path, spawn, startsWith,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  path = require("path");

  bower = require("bower");

  spawn = require("child_process").spawn;

  startsWith = function(s, w) {
    if (s.substr(0, w.length) === w) {
      return true;
    }
    return false;
  };

  CLITool = (function() {
    function CLITool(dir, binary) {
      this.binary = binary;
      this.run = bind(this.run, this);
      this.dir = path.resolve(dir);
    }

    CLITool.prototype.run = function(cmd, args, callback) {
      var a, arg, child, data, err, i, len, options;
      a = [cmd];
      for (i = 0, len = args.length; i < len; i++) {
        arg = args[i];
        a.push(arg);
      }
      options = {
        cwd: this.dir
      };
      child = spawn(this.binary, a, options);
      err = "";
      data = "";
      child.stderr.on("data", function(d) {
        return err += d;
      });
      child.stdout.on("data", function(d) {
        return data += d;
      });
      return child.on("close", function() {
        if (err.length < 1) {
          err = null;
        }
        return callback(err, data);
      });
    };

    return CLITool;

  })();

  Git = (function(superClass) {
    extend(Git, superClass);

    function Git(dir) {
      this.currentTag = bind(this.currentTag, this);
      this.status = bind(this.status, this);
      Git.__super__.constructor.call(this, dir, "git");
    }

    Git.prototype.status = function(callback) {
      return this.run("status", ["--porcelain"], function(err, res) {
        var parts;
        if (err != null) {
          return callback(err, null);
        }
        parts = res.split("\n").filter(function(l) {
          return l.length;
        }).map(function(p) {
          return {
            status: p.substr(0, 1),
            path: p.substr(2)
          };
        });
        return callback(null, parts);
      });
    };

    Git.prototype.currentTag = function(callback) {
      return this.run("describe", ["--exact-match", "HEAD"], function(err, res) {
        if (err != null) {
          if (startsWith(err, "fatal: no tag exactly matches")) {
            return callback(null, "");
          }
          return callback(err, null);
        }
        return callback(null, res.trim());
      });
    };

    return Git;

  })(CLITool);

  Bower = (function(superClass) {
    extend(Bower, superClass);

    function Bower(dir) {
      this.version = bind(this.version, this);
      Bower.__super__.constructor.call(this, dir, "bower");
    }

    Bower.prototype.version = function(str, callback) {
      return this.run("version", [str], function(err, res) {
        if (err != null) {
          return callback(err, null);
        }
        return callback(null, res.trim());
      });
    };

    return Bower;

  })(CLITool);

  module.exports = function(grunt) {
    return grunt.registerMultiTask('bower_link_snapshot', 'Grunt task for snapshotting bower linked components', function() {
      var doNext, done, options, pending, setDependsVersion;
      done = this.async();
      options = this.options({
        "packages": []
      });
      setDependsVersion = function(bowerPackage, version, done) {
        var bowerConfig, packagePath;
        grunt.log.writeln("Set bower version for " + bowerPackage + " to " + version);
        bowerConfig = grunt.file.readJSON("bower.json");
        if (!bowerConfig.dependencies.hasOwnProperty(bowerPackage)) {
          grunt.log.error("Bower package " + bowerPackage + " not found in bower.json");
          return done(false);
        }
        packagePath = bowerConfig.dependencies[bowerPackage];
        packagePath = packagePath.split("#")[0];
        packagePath = packagePath + "#" + version.substr(1);
        bowerConfig.dependencies[bowerPackage] = packagePath;
        grunt.file.write("bower.json", JSON.stringify(bowerConfig, null, 2));
        return done();
      };
      pending = options.packages;
      doNext = function(success) {
        var dir, p, repo;
        if (success === false) {
          return done(success);
        }
        if (pending.length < 1) {
          return done();
        }
        p = pending.pop();
        dir = "bower_components/" + p;
        repo = new Git(dir);
        return repo.status(function(err, res) {
          if (err != null) {
            return done(err);
          }
          if (res.length > 0) {
            grunt.log.writeln("Package " + p + " had un-committed changes");
            return done(false);
          }
          return repo.currentTag(function(err, res) {
            if (err != null) {
              grunt.log.writeln(err);
              return done(false);
            }
            if (res !== "") {
              return setDependsVersion(p, res, doNext);
            }
            bower = new Bower(dir);
            return bower.version("minor", function(err, res) {
              if (err != null) {
                grunt.log.error(err);
                return done(false);
              }
              grunt.log.writeln("Bump bower version to", res);
              return setDependsVersion(p, res, doNext);
            });
          });
        });
      };
      return doNext();
    });
  };

}).call(this);
